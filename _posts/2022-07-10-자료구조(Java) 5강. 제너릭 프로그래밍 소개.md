## 1.5 제너릭 프로그래밍 소개

**제너릭 프로그래밍은 다양한 자료형의 객체에 대해 작성한 코드를 재사용한다는 객체 지향 기법이다.**

```java
// 정렬 알고리즘 예시
public class ss{
	public int[] superSort(int[] array){
		// ...sort...
		return array;
	}
}
```

위와 같은 정렬 알고리즘이 있을 때, 이 정렬 함수를 int 외의 다른 자료형에 대해 사용하려면,   int를 String, Person 등 문자열, 원하는 객체로 일일이 바꿔야 했을 것.

하지만 제너릭 프로그래밍을 통해  1가지의 코드만 작성해서 이를 다른 자료형에 대해 재사용할 수 있게 만들 수 있게 되었다.

<br>

<br>

1️⃣ 객체 배열을 생성하고 그 안에 하위 객체를 담을 때 과정 :

```java
Object[] arr = new Object[10];
Student s = new Student();
Object obj = s; //Student객체의 s 를 Object 객체로 형변환
arr[0] = obj; //
```

<br>

<br>

<img src="/Users/dodokyumin/Documents/dodokyumin-github-blog/images/2022-07-10-자료구조(Java) 5강. 제너릭 프로그래밍 소개/스크린샷 2022-07-10 오후 7.00.48.png" alt="스크린샷 2022-07-10 오후 7.00.48" style="zoom:50%;" />

Undergraduate 에 대한 변수를 만들 때, 그 변수는 Undergraduate 클래스 안으로 들어간다.

그러면 그 year 메소드는 Student 클래스의 year 메소드를 오버라이드 한다.

비슷한 방식으로 Person 클래스에도 name이 있다. 이 때 Undergraduate 객체는 이 name을 오버라이드 한다. 만약 Undergraduate 클래스에 name 메소드가 없으면 Person 클래스의 name 메소드를 그대로 가져와서 사용하게 된다.

아래로 하향할 수록 데이터는 많아지고 힙에 할당되는 크기도 많아진다.

<br>

<br>

객체(Object) 클래스에는 중요한 메소드가 있다.

## 클래스를 정의할 때 오버라이드 해야할 메소드 3가지

### **equals( )**

하지만 객체 클래스에는 하위 Person, Student, Faculty, Undergraduate 등에 대한 정보를 담고 있지 않다. 객체에 대한 정보만을 담고있다.

그리하여 equals() 는 힙에서 가리키고 있는 위치가 같은지 알아보는 원리로 작동한다.

👉**메모리 위치를 비교하여 이 두 객체가 같은지 아닌지 알아내는 equals( ) 메소드**

<br>

하지만 Object의 equals( ) 는 하위 클래스 Person, Student, Undergraduate.. 등등을 비교할 때 사용하는 방법은 아니다. 메모리 위치를 비교하지는 않을 것이다. 

마치 Object.equals (객체 비교)가 아닌 String.equals (문자열 비교 즉, student, year, name 등 의 비교)를 사용해야하는 것처럼

<br>

따라서 하위 클래스를 정의할 때에 이 상위 클래스의 equals( ) 메소드를 오버라이드 하여야 한다. (두 Undergraduate이 같은지 아닌지 비교할 수 있는 방법을 알려주는 것)

<br>

<br>

### toString( )

객체를 출력할 때의 sysout에서 : 

```java
Student s = new Student();
System.out.println(s.toString()); //여기서는 객체의 메모리 위치만을 출력한다.
```

자바는 s.toString( ) 을 통해 이 Student 객체를 출력한다.

객체는 객체 클래스에 대한 정보만을 가지고 있기 때문에, 실질적인 하위 클래스들의 데이터가 아닌, 객체의 메모리 위치만을 출력한다.

그러므로, toString( )도 마찬가지로 클래스 정의할 때 오버라이드 해야 한다.

<br>

<br>

### hashCode( )

~~추후 다룰 예정~~

<br>

<br>

2️⃣ 아까 만들었던 객체 배열에 다시 여러 객체들을 담는다면,

```java
Object[] arr = new Object[10];
Student s = new Student();
Object obj = s; //Student객체의 s 를 Object 객체로 형변환
arr[0] = obj;

Monkey m = new Monkey(); //Monkey 객체를 만들고
arr[1] = m; //객체 배열에 넣는다.

String string = "Chalk & Cheese"; //문자열 객체를 만들어
arr[2] = s;	//객체 배열에 넣는다.
```

위 코드는 모두 객체로 형변환을 하고 객체 배열에 담았으므로 오류 없이 컴파일이 된다.

❗️하지만 서로 다른 종류의 것들을 모두 섞어서 넣었기 때문에 바람직하지는 않은 코드이다.



이때 사용할 수 있는 방법이 **매개변수화 타입(Parameterized Types)** 이라고 부르는 것이다.

매개변수화 타입을 사용하면,

👉 특정 종류의 공간에 넣을 내용을 정의할 수 있게 된다.

<br>

<br>

위 메소드들의 오버라이드 방법 참고 : [클래스를 정의 했을 때 할 일 -dodokyumin](https://dodokyumin.github.io/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%A0%95%EC%9D%98%ED%96%88%EC%9D%84-%EB%95%8C-%ED%95%A0-%EC%9D%BC-(Webmarket-%EA%B5%AC%ED%98%84-1)/)

<br>

<br>

<br>

## 생각해보기

\1) 제너릭 프로그래밍의 장점은 무엇인가요?

**1.** 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.

**2.** 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.

**3.** 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

<br>

<br>

<br>

## References

> 자바로 구현하고 배우는 자료구조 -Rob Edwards (boostcourse) 