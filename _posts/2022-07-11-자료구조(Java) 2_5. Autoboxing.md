# Autoboxing

**Autoboxing**

- 원시 타입의 값을 해당하는 wrapper 클래스의 객체로 바꾸는 과정을 의미

**Unboxing**

- Wrapper 클래스 타입을 원시 타입으로 변환하는 과정의 의미



| Primitives | Wrapper |
| :--------: | :-----: |
|    byte    |  Byte   |
|   short    |  Short  |
|    int     | Integer |
|    long    |  Long   |
|   double   | Double  |
|    char    |  Char   |
|  boolean   | Boolean |

byte, short, int, char 등의 기본 자료형에 대해서 Java 가상 머신은 정확하게 필요한 만큼의 메모리를 할당한다.

 하지만 객체에 대해서는 이 객체를 가리키는 4바이트짜리 포인터와 힙의 공간을 할당한다.



따라서 **기본 자료형은 객체가 아니**고 이것들은 객체 메소드를 상속받지 않는다. 

하지만 Java에는 기본 자료형뿐만 아니라 **래퍼 클래스(Wrapper Class)**가 존재한다. 

래퍼 클래스는 객체 버전의 기본 자료형이다.

 byte는 Byte, short는 Short, int는 Integer, char는 Char로 바꾸면 됩니다.



이 둘 사이에서 Java는 **autoboxing**을 이용해서 **이 둘을 적절하게 서로 바꾼다.**



<br>

### 기본 타입과 박싱 된 타입의 차이

 

1. 기본 타입은 값만 가지고 있지만 박싱 된 타입은 값 + 식별성이라는 속성을 갖는다.

👉즉 박싱된 타입의 두 인스턴스는 값이 같아도 다르다고 식별될 수 있다.



2. 기본 타입의 값은 NULL을 허용하지만 박싱된 타입은 허용하지 않는다.

 

 **3. 기본 타입이 박싱된 타입보다 시간과 메모리 사용면에서 효율적이다.**

<br>

<br>

<br>

## 생각해보기

\1) 래퍼 클래스는 기본 자료형과 어떤 점이 다른가요?



객체이기 때문에 상속이 가능하고 메소드 이용도 가능하다.

Null을 허용하지 않는다.

시간과 메모리 사용면에서 비효율적이다.

박싱된 타입의 두 인스턴스는  값이 같아도 다르다고 식별될 수 있다.

<br>

<br>

<br>

## References

> 자바로 구현하고 배우는 자료구조 -Rob Edwards (boostcourse) 