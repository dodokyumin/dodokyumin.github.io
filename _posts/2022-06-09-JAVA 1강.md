---
layout: single
title: "Java 개념 정리 01"
categories: Java
tag: Encapsulation
---

리액트 앵귤러 등 프레임워크는 코드를 가려준다.

# JAVA

객체 지향 패러다임의 4가지 주요 특성인 “캡슐화”, “추상화”, “다형성”, “상속”.

## 캡슐화(Encapsulation)

​ " 내 이름을 getter setter를 사용하여 남이 마음대로 못 고치게 하는 것.

막 냅두면 그게 c언어이다. "

​ **연관된 목적을 가지는 변수와 함수를 하나의 클래스로 묶어, 외부에서 쉽게 접근하지 못하도록 보호하기 위해 사용하는 것. 객체가 제공하는 필드와 메소드를 통해서만 접근이 가능하다.**

<br>

✔ 유지보수나 확장 시에 오류의 범위를 최소화 할 수 있다.

✔ 객체 내의 정보 손상과 오용을 방지하고, 데이터가 변경되어도 다른 객체에 영향을 주지 않아 독립성이 좋다.

<br>

### 캡슐화 방법

1. 변수에게 접근 제어자 private을 붙이기. (ex private : 자기 클래스에서만 접근할 수 있는 것)

2. 멤버 변수에 값을 넣고 꺼내 올 수 있는 메소드를 만들기. (ex getter setter)

<br>

**<캡슐화 클래스>**

```java
package Encapsulation;

public class capsuleEx {
	private String name;
	private int age;

    //getter
    public int getName(){
        return name;
    }
    public int getAge(){
        return age;
    }

    //setter
    public void setName(String name){
        this.name = name;
    }
    public void setAge(int age){
        this.age = age;
    }
}
```

<br>

**<메인 클래스>**

```java
package Encapsulation;

public class Main {

    public static void main(String[] args) {

        capsuleEx cap = new capsuleEx();

        cap.setName("Hong");
        cap.setAge(27);

        System.out.println(cap.getName());
        System.out.println(cap.getAge());
    }
}
```

<br>

**<결과 화면>**

```
Hong
27
```

<br>

<br>

<br>

<br>

<br>

## 인스턴스 (Instance)

​ 인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미한다.

클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상'을 의미한다.

<br>

​ 즉, 클래스로 인스턴스를 만든다.

ex) 인스타그램의 클래스는

<user **객체(인스턴스)**의 틀**(클래스)**>

```
속성 : {이름, 이메일주소, 비밀번호, 팔로우 목록, 팔로워 목록 },

행동 : {글 업로드하기, 팔로우하기}
```

이렇게 이루어져 있다.

<br>

새로운 회원이 회원가입을 할 때마다 이 **클래스**로 **인스턴스**를 찍어내어 유저를 받고 수를 늘린다.

<br>

<br>

##### 객체(Object) VS 인스턴스(Instance)

- 클래스의 타입으로 선언 되었을 때, 객체라 부른다. 그 객체가 메모리에 할당되어(새 유저를 받아 등록) 실제 사용될 때 인스턴스라고 부른다.
- 객체는 현실세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
- 객체는 '실체', 인스턴스는 '관계'에 초점을 맞춘다.
  - 객체를 '클래스의 인스턴스'라고도 부른다.

<br>

##### 인스턴스화(Instantiation)

​ 클래스를 통해 인스턴스를 찍어내는 것.

<br>

#### 인스턴스 생성(인스턴스화)하기 :

```java
 클래스명 변수명 = new 클래스명;
```

```java
Gongsa gongsa = new Gongsa(a, b, R);
```

<br>

<br>

<br>

<br>

<br>

## 다형성

​ 하나의 객체에 여러가지 타입을 대입할 수 있다는 것.

다형성을 구현하는 대표적인 방법 3가지

- 오버로딩
- 오버라이딩
- 함수형 인터페이스

<br>

##### 다형성의 예시 :

```java
Animal animal = new Dog();
// 개는 동물이다. O
Sonata sonata = new Car();
// 차는 소나타다. X
```

<br>

<br>

<br>

<br>

<br>

## 상속

​ 상속의 궁극적인 이유는 기능의 확장.

​ class 슈퍼맨 extends 남자

<br>

<br>

<br>

<br>

<br>

## String의 속성

모든 언어 공통

**String 은 대표적인 불변객체.**

한번 세팅되면 절대 변하지 않는다.

자바는 c언어처럼 메모리 주소를 볼 수는 없지만,

hash code를 통해 알 수 있다.

모든 객체에 hash code가 있다. hash code메소드는 int값을 리턴.

```java
String greeting = "Hello";
System.out.println(greeting.hashCode());

greeting = greeting + "!!!";
System.out.println(greeting.hashCode());
```

접근은 greeting으로 접근이 되지만 "!!!"를 붙인 문자열을 새로 저장해 해시코드를 새로 받기 때문에 결국 다른 메모리.

근데 String 객체도 클래스로 만든 것. 그럼 객체 생성할 때

```
String greeting = new String("Hello");
```

가 되어야 하는데 왜 new를 안씀?

실제로는

```java
String greeting = new String("Hello");
```

이고, 암묵적으로 생략한 것 뿐.

<br>

<br>

```java
String greeting = "Hello, World!";

String greeting2 = greeting;

greeting2.toUpperCase();


System.out.println(greeting);

System.out.println(greeting2);
```

모두 여전히 "Hello, World!"이다. 왜냐하면 **String은 불변 객체**이다.

중간에 무슨 짓을 하더라도 안바뀐다.

<br>

**그럼 int 자료형은?**

```java
int luckyNumber = 13;

int luckyNumber2 = luckyNumber;

luckyNumber2 = 12;
```

이때,

luckyNuumvber 의 값은 13;

luckyNuumvber2 의 값은 12;

int는 원시 객체를 넣는 타입이다. 정말 있는 그대로를 넣는다.

<br>

<br>

#### 원시 타입(Primitive Type)이란?

​ 정수, 실수 문자, 논리 리터럴등의 **실제 테이터 값을 저장하는 타입**이다.

<br>

#### 참조 타입(Reference Type)이란?

​ 객체(Object)의 번지를 참조(주소를 저장)하는 타입으로 **메모리 번지 값을 통해 객체를 참조하는 타입**이다.

<br>

<br>

<br>

<br>

### Mutator(setter)

인스턴스 변수의 값을 설정하는 역할.

어떤 메소드를 통해서 자체의 속성이 변한다.

```java
Rectangle box = new Rectangle(5,10,60,40);

box.translate(25,40);
```

translate라는 메소드를 통해 속성을 재설정해줌.

```java
Rectangle box = new Recrtangle(5,10,60,90);

Rectangle box2 = box;

//x, y값을 받아 위치를 그만큼 이동시켜주는 translate()
box.translate(100,100);
```

box.getX()=?

box2.getX()=?

정답:

box.getX() = 105

box2.getX() = 105

**new가 하나이므로 실체는 하나.**

별명을 붙여준 것 뿐. 레퍼런스타입

그저 new를 box로 부를거고 box2로도 부를 것 이란 것.

<br>

<br>

<br>

<br>

<br>

## **정확성**

​ 모든 언어에서 모든 double은 연산 결과가 정확하지 않다.

컴퓨터는 쉬프트 연산을 통해 소수점을 구하기 때문에 정확한 소수자리를 구할 수 없다.

~~ex) 러시아의 한 로켓 발사과정에서 double 타입의 정확성 문제로 로켓이 불발했다.~~

<br>

<br>

<br>

<br>

<br>

## ✨TIPS

- boolean 자료형의 변수 이름은 is~ has~ 이렇게 정의하는 것을 지향하자. (가독성 up)

- 메소드는 재활용을 할 수 있다면 최대한 재활용 하는 것이 좋다.

- Stringbuffer : 멀티 스레드환경에서ㅗ 사용와

  Stringbuilder : 얘가 더 빠름.

  문자열에서는 더하기를 제거하는것이 제일 좋음.

- 주의가 필요한 java nextLine

프리미티브타입. 레포타입.

제너릭에서는 레포타입으로 써야한다.

<br>

<br>

<br>

<br>

<br>

## 배운점

```java
Scanner sc = new Scanner(System.in);
		String conInfo = sc.nextLine();

		String[] conInfoArr = conInfo.split(" ");
		int a = Integer.parseInt(conInfoArr[0]);
		int b = Integer.parseInt(conInfoArr[1]);
		int R = Integer.parseInt(conInfoArr[2]);
```

```java
Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		int R = sc.nextInt();
```

​ nextInt(); 로도 콘솔창의 입력값들을 가져올 수 있다.

공백 기준으로 끊어서 변수에 저장된다.

객체지향 : 사물 입장에서 코드를 쓰자.

## References

> 캡슐화 : https://jaynamm.tistory.com/entry/JAVA-%EC%9E%90%EB%B0%94-%EC%BA%A1%EC%8A%90%ED%99%94-Encapsulation
>
> 인스턴스 : https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
